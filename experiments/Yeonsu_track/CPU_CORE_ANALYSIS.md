# CPU 코어 사용 분석

## 라즈베리파이 4B 코어 구성
- **총 4개 코어**: ARM Cortex-A72 쿼드코어 (1.5GHz 또는 1.8GHz)
- **현재 사용**: 코어 0, 코어 1 (2개)
- **미사용**: 코어 2, 코어 3 (2개)

## 현재 구조 분석

### 코어 0: 메인 제어 프로세스
- **작업**: PID 계산, 모터/서보 제어
- **CPU 사용률**: 중간 (계산 집약적)
- **주기**: 0.5ms (2000 Hz)
- **특징**: 실시간 제어, 지연 최소화 필요

### 코어 1: 센서 프로세스
- **작업**: 초음파 센서 읽기, 필터링
- **CPU 사용률**: 낮음 (대부분 I/O 대기)
- **주기**: 2ms (500 Hz)
- **특징**: 하드웨어 대기 시간이 많음

## 왜 더 많은 코어를 사용하지 않는가?

### 1. **프로세스 간 통신 오버헤드**
```
현재: 센서 프로세스 → Lock → 제어 프로세스
추가 시: 센서 프로세스들 → Lock 경합 증가 → 지연 증가
```

### 2. **Lock 경합 증가**
- 여러 프로세스가 동시에 공유 메모리에 접근
- Lock 대기 시간 증가
- 실시간성 저하

### 3. **캐시 미스 증가**
- 각 코어가 별도의 캐시 사용
- 데이터 공유 시 캐시 동기화 오버헤드
- 성능 저하

### 4. **불필요한 컨텍스트 스위칭**
- 프로세스가 많을수록 스케줄링 오버헤드 증가
- 실시간 제어에 부정적 영향

## 추가 코어 활용 방안 (선택사항)

### 방안 1: 센서를 좌우로 분리 (비권장)
```python
# 코어 1: 왼쪽 센서
# 코어 2: 오른쪽 센서
```
**문제점:**
- Lock 경합 증가
- 센서 읽기는 순차적으로 해도 충분히 빠름
- 오버헤드만 증가

### 방안 2: 로깅 프로세스 분리 (선택사항)
```python
# 코어 2: 로깅/데이터 수집
```
**장점:**
- 제어 루프에서 로깅 오버헤드 제거
**단점:**
- 추가 프로세스 관리 복잡도
- 실시간성에는 큰 영향 없음

### 방안 3: 예측/경로 계획 (고급)
```python
# 코어 2: 경로 예측
# 코어 3: 최적 속도 계산
```
**장점:**
- 고급 알고리즘 구현 가능
**단점:**
- 복잡도 증가
- 현재 구조에서는 불필요

## 성능 비교

### 현재 구조 (2 코어)
- ✅ Lock 경합 최소
- ✅ 캐시 효율 최대
- ✅ 실시간성 보장
- ✅ 오버헤드 최소

### 4 코어 사용 시
- ❌ Lock 경합 증가
- ❌ 캐시 미스 증가
- ❌ 오버헤드 증가
- ⚠️ 성능 저하 가능성

## 결론

**현재 2 코어 구조가 최적입니다!**

이유:
1. 센서 읽기는 I/O 대기 시간이 많아 CPU 사용률이 낮음
2. 제어 로직은 이미 충분히 빠름
3. 추가 코어는 오히려 오버헤드만 증가
4. 실시간 제어에는 단순한 구조가 더 안정적

## 권장사항

### 현재 구조 유지 (권장)
- 코어 0: 제어
- 코어 1: 센서
- 코어 2, 3: 시스템/기타 프로세스용으로 여유 유지

### 추가 코어가 필요한 경우
1. **로깅이 너무 많을 때**: 코어 2에 로깅 프로세스
2. **고급 알고리즘 필요 시**: 코어 2, 3에 예측/계획 프로세스
3. **다른 작업 병행 시**: 코어 2, 3 활용

### 성능 모니터링
```bash
# CPU 사용률 확인
htop

# 코어별 사용률 확인
mpstat -P ALL 1
```

## 실제 측정 결과 (예상)

| 구조 | 제어 지연 | CPU 사용률 | 안정성 |
|------|----------|-----------|--------|
| 2 코어 (현재) | 0.5ms | 30-40% | ⭐⭐⭐⭐⭐ |
| 4 코어 (센서 분리) | 0.6-0.8ms | 40-50% | ⭐⭐⭐ |
| 4 코어 (로깅 분리) | 0.5ms | 35-45% | ⭐⭐⭐⭐ |

**결론: 현재 구조가 가장 효율적입니다!**

